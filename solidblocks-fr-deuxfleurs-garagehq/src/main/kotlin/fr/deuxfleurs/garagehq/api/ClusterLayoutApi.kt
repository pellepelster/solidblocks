/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package fr.deuxfleurs.garagehq.api

import java.io.IOException
import okhttp3.Call
import okhttp3.HttpUrl

import fr.deuxfleurs.garagehq.model.ApplyClusterLayoutRequest
import fr.deuxfleurs.garagehq.model.ApplyClusterLayoutResponse
import fr.deuxfleurs.garagehq.model.ClusterLayoutSkipDeadNodesRequest
import fr.deuxfleurs.garagehq.model.ClusterLayoutSkipDeadNodesResponse
import fr.deuxfleurs.garagehq.model.GetClusterLayoutHistoryResponse
import fr.deuxfleurs.garagehq.model.GetClusterLayoutResponse
import fr.deuxfleurs.garagehq.model.PreviewClusterLayoutChangesResponse
import fr.deuxfleurs.garagehq.model.UpdateClusterLayoutRequest

import com.squareup.moshi.Json

import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import org.openapitools.client.infrastructure.ApiClient
import org.openapitools.client.infrastructure.ApiResponse
import org.openapitools.client.infrastructure.ClientException
import org.openapitools.client.infrastructure.ClientError
import org.openapitools.client.infrastructure.ServerException
import org.openapitools.client.infrastructure.ServerError
import org.openapitools.client.infrastructure.MultiValueMap
import org.openapitools.client.infrastructure.PartConfig
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod
import org.openapitools.client.infrastructure.ResponseType
import org.openapitools.client.infrastructure.Success
import org.openapitools.client.infrastructure.toMultiValue

open class ClusterLayoutApi(basePath: kotlin.String = defaultBasePath, client: Call.Factory = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "http://localhost:3903")
        }
    }

    /**
     * POST /v2/ApplyClusterLayout
     * 
     *  Applies to the cluster the layout changes currently registered as staged layout changes.  *Note: do not try to parse the &#x60;message&#x60; field of the response, it is given as an array of string specifically because its format is not stable.*     
     * @param applyClusterLayoutRequest 
     * @return ApplyClusterLayoutResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun applyClusterLayout(applyClusterLayoutRequest: ApplyClusterLayoutRequest) : ApplyClusterLayoutResponse = withContext(Dispatchers.IO) {
        val localVarResponse = applyClusterLayoutWithHttpInfo(applyClusterLayoutRequest = applyClusterLayoutRequest)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ApplyClusterLayoutResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /v2/ApplyClusterLayout
     * 
     *  Applies to the cluster the layout changes currently registered as staged layout changes.  *Note: do not try to parse the &#x60;message&#x60; field of the response, it is given as an array of string specifically because its format is not stable.*     
     * @param applyClusterLayoutRequest 
     * @return ApiResponse<ApplyClusterLayoutResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun applyClusterLayoutWithHttpInfo(applyClusterLayoutRequest: ApplyClusterLayoutRequest) : ApiResponse<ApplyClusterLayoutResponse?> = withContext(Dispatchers.IO) {
        val localVariableConfig = applyClusterLayoutRequestConfig(applyClusterLayoutRequest = applyClusterLayoutRequest)

        return@withContext request<ApplyClusterLayoutRequest, ApplyClusterLayoutResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation applyClusterLayout
     *
     * @param applyClusterLayoutRequest 
     * @return RequestConfig
     */
    fun applyClusterLayoutRequestConfig(applyClusterLayoutRequest: ApplyClusterLayoutRequest) : RequestConfig<ApplyClusterLayoutRequest> {
        val localVariableBody = applyClusterLayoutRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/v2/ApplyClusterLayout",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /v2/ClusterLayoutSkipDeadNodes
     * 
     * Force progress in layout update trackers
     * @param clusterLayoutSkipDeadNodesRequest 
     * @return ClusterLayoutSkipDeadNodesResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun clusterLayoutSkipDeadNodes(clusterLayoutSkipDeadNodesRequest: ClusterLayoutSkipDeadNodesRequest) : ClusterLayoutSkipDeadNodesResponse = withContext(Dispatchers.IO) {
        val localVarResponse = clusterLayoutSkipDeadNodesWithHttpInfo(clusterLayoutSkipDeadNodesRequest = clusterLayoutSkipDeadNodesRequest)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ClusterLayoutSkipDeadNodesResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /v2/ClusterLayoutSkipDeadNodes
     * 
     * Force progress in layout update trackers
     * @param clusterLayoutSkipDeadNodesRequest 
     * @return ApiResponse<ClusterLayoutSkipDeadNodesResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun clusterLayoutSkipDeadNodesWithHttpInfo(clusterLayoutSkipDeadNodesRequest: ClusterLayoutSkipDeadNodesRequest) : ApiResponse<ClusterLayoutSkipDeadNodesResponse?> = withContext(Dispatchers.IO) {
        val localVariableConfig = clusterLayoutSkipDeadNodesRequestConfig(clusterLayoutSkipDeadNodesRequest = clusterLayoutSkipDeadNodesRequest)

        return@withContext request<ClusterLayoutSkipDeadNodesRequest, ClusterLayoutSkipDeadNodesResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation clusterLayoutSkipDeadNodes
     *
     * @param clusterLayoutSkipDeadNodesRequest 
     * @return RequestConfig
     */
    fun clusterLayoutSkipDeadNodesRequestConfig(clusterLayoutSkipDeadNodesRequest: ClusterLayoutSkipDeadNodesRequest) : RequestConfig<ClusterLayoutSkipDeadNodesRequest> {
        val localVariableBody = clusterLayoutSkipDeadNodesRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/v2/ClusterLayoutSkipDeadNodes",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /v2/GetClusterLayout
     * 
     *  Returns the cluster&#39;s current layout, including:  - Currently configured cluster layout - Staged changes to the cluster layout  *Capacity is given in bytes*     
     * @return GetClusterLayoutResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun getClusterLayout() : GetClusterLayoutResponse = withContext(Dispatchers.IO) {
        val localVarResponse = getClusterLayoutWithHttpInfo()

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetClusterLayoutResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v2/GetClusterLayout
     * 
     *  Returns the cluster&#39;s current layout, including:  - Currently configured cluster layout - Staged changes to the cluster layout  *Capacity is given in bytes*     
     * @return ApiResponse<GetClusterLayoutResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun getClusterLayoutWithHttpInfo() : ApiResponse<GetClusterLayoutResponse?> = withContext(Dispatchers.IO) {
        val localVariableConfig = getClusterLayoutRequestConfig()

        return@withContext request<Unit, GetClusterLayoutResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getClusterLayout
     *
     * @return RequestConfig
     */
    fun getClusterLayoutRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/GetClusterLayout",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /v2/GetClusterLayoutHistory
     * 
     *  Returns the history of layouts in the cluster     
     * @return GetClusterLayoutHistoryResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun getClusterLayoutHistory() : GetClusterLayoutHistoryResponse = withContext(Dispatchers.IO) {
        val localVarResponse = getClusterLayoutHistoryWithHttpInfo()

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetClusterLayoutHistoryResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v2/GetClusterLayoutHistory
     * 
     *  Returns the history of layouts in the cluster     
     * @return ApiResponse<GetClusterLayoutHistoryResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun getClusterLayoutHistoryWithHttpInfo() : ApiResponse<GetClusterLayoutHistoryResponse?> = withContext(Dispatchers.IO) {
        val localVariableConfig = getClusterLayoutHistoryRequestConfig()

        return@withContext request<Unit, GetClusterLayoutHistoryResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getClusterLayoutHistory
     *
     * @return RequestConfig
     */
    fun getClusterLayoutHistoryRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/GetClusterLayoutHistory",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /v2/PreviewClusterLayoutChanges
     * 
     *  Computes a new layout taking into account the staged parameters, and returns it with detailed statistics. The new layout is not applied in the cluster.  *Note: do not try to parse the &#x60;message&#x60; field of the response, it is given as an array of string specifically because its format is not stable.*     
     * @return PreviewClusterLayoutChangesResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun previewClusterLayoutChanges() : PreviewClusterLayoutChangesResponse = withContext(Dispatchers.IO) {
        val localVarResponse = previewClusterLayoutChangesWithHttpInfo()

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PreviewClusterLayoutChangesResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /v2/PreviewClusterLayoutChanges
     * 
     *  Computes a new layout taking into account the staged parameters, and returns it with detailed statistics. The new layout is not applied in the cluster.  *Note: do not try to parse the &#x60;message&#x60; field of the response, it is given as an array of string specifically because its format is not stable.*     
     * @return ApiResponse<PreviewClusterLayoutChangesResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun previewClusterLayoutChangesWithHttpInfo() : ApiResponse<PreviewClusterLayoutChangesResponse?> = withContext(Dispatchers.IO) {
        val localVariableConfig = previewClusterLayoutChangesRequestConfig()

        return@withContext request<Unit, PreviewClusterLayoutChangesResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation previewClusterLayoutChanges
     *
     * @return RequestConfig
     */
    fun previewClusterLayoutChangesRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/v2/PreviewClusterLayoutChanges",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /v2/RevertClusterLayout
     * 
     * Clear staged layout changes
     * @return GetClusterLayoutResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun revertClusterLayout() : GetClusterLayoutResponse = withContext(Dispatchers.IO) {
        val localVarResponse = revertClusterLayoutWithHttpInfo()

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetClusterLayoutResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /v2/RevertClusterLayout
     * 
     * Clear staged layout changes
     * @return ApiResponse<GetClusterLayoutResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun revertClusterLayoutWithHttpInfo() : ApiResponse<GetClusterLayoutResponse?> = withContext(Dispatchers.IO) {
        val localVariableConfig = revertClusterLayoutRequestConfig()

        return@withContext request<Unit, GetClusterLayoutResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation revertClusterLayout
     *
     * @return RequestConfig
     */
    fun revertClusterLayoutRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/v2/RevertClusterLayout",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /v2/UpdateClusterLayout
     * 
     *  Send modifications to the cluster layout. These modifications will be included in the staged role changes, visible in subsequent calls of &#x60;GET /GetClusterHealth&#x60;. Once the set of staged changes is satisfactory, the user may call &#x60;POST /ApplyClusterLayout&#x60; to apply the changed changes, or &#x60;POST /RevertClusterLayout&#x60; to clear all of the staged changes in the layout.  Setting the capacity to &#x60;null&#x60; will configure the node as a gateway. Otherwise, capacity must be now set in bytes (before Garage 0.9 it was arbitrary weights). For example to declare 100GB, you must set &#x60;capacity: 100000000000&#x60;.  Garage uses internally the International System of Units (SI), it assumes that 1kB &#x3D; 1000 bytes, and displays storage as kB, MB, GB (and not KiB, MiB, GiB that assume 1KiB &#x3D; 1024 bytes).     
     * @param updateClusterLayoutRequest  To add a new node to the layout or to change the configuration of an existing node, simply set the values you want (&#x60;zone&#x60;, &#x60;capacity&#x60;, and &#x60;tags&#x60;). To remove a node, simply pass the &#x60;remove: true&#x60; field. This logic is represented in OpenAPI with a &#39;One Of&#39; object.  Contrary to the CLI that may update only a subset of the fields capacity, zone and tags, when calling this API all of these values must be specified.         
     * @return GetClusterLayoutResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun updateClusterLayout(updateClusterLayoutRequest: UpdateClusterLayoutRequest) : GetClusterLayoutResponse = withContext(Dispatchers.IO) {
        val localVarResponse = updateClusterLayoutWithHttpInfo(updateClusterLayoutRequest = updateClusterLayoutRequest)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetClusterLayoutResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /v2/UpdateClusterLayout
     * 
     *  Send modifications to the cluster layout. These modifications will be included in the staged role changes, visible in subsequent calls of &#x60;GET /GetClusterHealth&#x60;. Once the set of staged changes is satisfactory, the user may call &#x60;POST /ApplyClusterLayout&#x60; to apply the changed changes, or &#x60;POST /RevertClusterLayout&#x60; to clear all of the staged changes in the layout.  Setting the capacity to &#x60;null&#x60; will configure the node as a gateway. Otherwise, capacity must be now set in bytes (before Garage 0.9 it was arbitrary weights). For example to declare 100GB, you must set &#x60;capacity: 100000000000&#x60;.  Garage uses internally the International System of Units (SI), it assumes that 1kB &#x3D; 1000 bytes, and displays storage as kB, MB, GB (and not KiB, MiB, GiB that assume 1KiB &#x3D; 1024 bytes).     
     * @param updateClusterLayoutRequest  To add a new node to the layout or to change the configuration of an existing node, simply set the values you want (&#x60;zone&#x60;, &#x60;capacity&#x60;, and &#x60;tags&#x60;). To remove a node, simply pass the &#x60;remove: true&#x60; field. This logic is represented in OpenAPI with a &#39;One Of&#39; object.  Contrary to the CLI that may update only a subset of the fields capacity, zone and tags, when calling this API all of these values must be specified.         
     * @return ApiResponse<GetClusterLayoutResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun updateClusterLayoutWithHttpInfo(updateClusterLayoutRequest: UpdateClusterLayoutRequest) : ApiResponse<GetClusterLayoutResponse?> = withContext(Dispatchers.IO) {
        val localVariableConfig = updateClusterLayoutRequestConfig(updateClusterLayoutRequest = updateClusterLayoutRequest)

        return@withContext request<UpdateClusterLayoutRequest, GetClusterLayoutResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation updateClusterLayout
     *
     * @param updateClusterLayoutRequest  To add a new node to the layout or to change the configuration of an existing node, simply set the values you want (&#x60;zone&#x60;, &#x60;capacity&#x60;, and &#x60;tags&#x60;). To remove a node, simply pass the &#x60;remove: true&#x60; field. This logic is represented in OpenAPI with a &#39;One Of&#39; object.  Contrary to the CLI that may update only a subset of the fields capacity, zone and tags, when calling this API all of these values must be specified.         
     * @return RequestConfig
     */
    fun updateClusterLayoutRequestConfig(updateClusterLayoutRequest: UpdateClusterLayoutRequest) : RequestConfig<UpdateClusterLayoutRequest> {
        val localVariableBody = updateClusterLayoutRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/v2/UpdateClusterLayout",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
