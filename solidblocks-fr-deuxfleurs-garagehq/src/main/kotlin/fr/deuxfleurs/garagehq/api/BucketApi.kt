/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package fr.deuxfleurs.garagehq.api

import java.io.IOException
import okhttp3.Call
import okhttp3.HttpUrl

import fr.deuxfleurs.garagehq.model.CleanupIncompleteUploadsRequest
import fr.deuxfleurs.garagehq.model.CleanupIncompleteUploadsResponse
import fr.deuxfleurs.garagehq.model.CreateBucketRequest
import fr.deuxfleurs.garagehq.model.GetBucketInfoResponse
import fr.deuxfleurs.garagehq.model.InspectObjectResponse
import fr.deuxfleurs.garagehq.model.ListBucketsResponseItem
import fr.deuxfleurs.garagehq.model.UpdateBucketRequestBody

import com.squareup.moshi.Json

import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import org.openapitools.client.infrastructure.ApiClient
import org.openapitools.client.infrastructure.ApiResponse
import org.openapitools.client.infrastructure.ClientException
import org.openapitools.client.infrastructure.ClientError
import org.openapitools.client.infrastructure.ServerException
import org.openapitools.client.infrastructure.ServerError
import org.openapitools.client.infrastructure.MultiValueMap
import org.openapitools.client.infrastructure.PartConfig
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod
import org.openapitools.client.infrastructure.ResponseType
import org.openapitools.client.infrastructure.Success
import org.openapitools.client.infrastructure.toMultiValue

open class BucketApi(basePath: kotlin.String = defaultBasePath, client: Call.Factory = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "http://localhost:3903")
        }
    }

    /**
     * POST /v2/CleanupIncompleteUploads
     * 
     * Removes all incomplete multipart uploads that are older than the specified number of seconds.
     * @param cleanupIncompleteUploadsRequest 
     * @return CleanupIncompleteUploadsResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun cleanupIncompleteUploads(cleanupIncompleteUploadsRequest: CleanupIncompleteUploadsRequest) : CleanupIncompleteUploadsResponse = withContext(Dispatchers.IO) {
        val localVarResponse = cleanupIncompleteUploadsWithHttpInfo(cleanupIncompleteUploadsRequest = cleanupIncompleteUploadsRequest)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CleanupIncompleteUploadsResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /v2/CleanupIncompleteUploads
     * 
     * Removes all incomplete multipart uploads that are older than the specified number of seconds.
     * @param cleanupIncompleteUploadsRequest 
     * @return ApiResponse<CleanupIncompleteUploadsResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun cleanupIncompleteUploadsWithHttpInfo(cleanupIncompleteUploadsRequest: CleanupIncompleteUploadsRequest) : ApiResponse<CleanupIncompleteUploadsResponse?> = withContext(Dispatchers.IO) {
        val localVariableConfig = cleanupIncompleteUploadsRequestConfig(cleanupIncompleteUploadsRequest = cleanupIncompleteUploadsRequest)

        return@withContext request<CleanupIncompleteUploadsRequest, CleanupIncompleteUploadsResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation cleanupIncompleteUploads
     *
     * @param cleanupIncompleteUploadsRequest 
     * @return RequestConfig
     */
    fun cleanupIncompleteUploadsRequestConfig(cleanupIncompleteUploadsRequest: CleanupIncompleteUploadsRequest) : RequestConfig<CleanupIncompleteUploadsRequest> {
        val localVariableBody = cleanupIncompleteUploadsRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/v2/CleanupIncompleteUploads",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /v2/CreateBucket
     * 
     *  Creates a new bucket, either with a global alias, a local one, or no alias at all. Technically, you can also specify both &#x60;globalAlias&#x60; and &#x60;localAlias&#x60; and that would create two aliases.     
     * @param createBucketRequest 
     * @return GetBucketInfoResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun createBucket(createBucketRequest: CreateBucketRequest) : GetBucketInfoResponse = withContext(Dispatchers.IO) {
        val localVarResponse = createBucketWithHttpInfo(createBucketRequest = createBucketRequest)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetBucketInfoResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /v2/CreateBucket
     * 
     *  Creates a new bucket, either with a global alias, a local one, or no alias at all. Technically, you can also specify both &#x60;globalAlias&#x60; and &#x60;localAlias&#x60; and that would create two aliases.     
     * @param createBucketRequest 
     * @return ApiResponse<GetBucketInfoResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun createBucketWithHttpInfo(createBucketRequest: CreateBucketRequest) : ApiResponse<GetBucketInfoResponse?> = withContext(Dispatchers.IO) {
        val localVariableConfig = createBucketRequestConfig(createBucketRequest = createBucketRequest)

        return@withContext request<CreateBucketRequest, GetBucketInfoResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation createBucket
     *
     * @param createBucketRequest 
     * @return RequestConfig
     */
    fun createBucketRequestConfig(createBucketRequest: CreateBucketRequest) : RequestConfig<CreateBucketRequest> {
        val localVariableBody = createBucketRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/v2/CreateBucket",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /v2/DeleteBucket
     * 
     *  Deletes a storage bucket. A bucket cannot be deleted if it is not empty.  **Warning:** this will delete all aliases associated with the bucket!     
     * @param id ID of the bucket to delete
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun deleteBucket(id: kotlin.String) : Unit = withContext(Dispatchers.IO) {
        val localVarResponse = deleteBucketWithHttpInfo(id = id)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /v2/DeleteBucket
     * 
     *  Deletes a storage bucket. A bucket cannot be deleted if it is not empty.  **Warning:** this will delete all aliases associated with the bucket!     
     * @param id ID of the bucket to delete
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun deleteBucketWithHttpInfo(id: kotlin.String) : ApiResponse<Unit?> = withContext(Dispatchers.IO) {
        val localVariableConfig = deleteBucketRequestConfig(id = id)

        return@withContext request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation deleteBucket
     *
     * @param id ID of the bucket to delete
     * @return RequestConfig
     */
    fun deleteBucketRequestConfig(id: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("id", listOf(id.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/v2/DeleteBucket",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /v2/GetBucketInfo
     * 
     *  Given a bucket identifier (&#x60;id&#x60;) or a global alias (&#x60;alias&#x60;), get its information. It includes its aliases, its web configuration, keys that have some permissions on it, some statistics (number of objects, size), number of dangling multipart uploads, and its quotas (if any).     
     * @param id Exact bucket ID to look up (optional)
     * @param globalAlias Global alias of bucket to look up (optional)
     * @param search Partial ID or alias to search for (optional)
     * @return GetBucketInfoResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun getBucketInfo(id: kotlin.String? = null, globalAlias: kotlin.String? = null, search: kotlin.String? = null) : GetBucketInfoResponse = withContext(Dispatchers.IO) {
        val localVarResponse = getBucketInfoWithHttpInfo(id = id, globalAlias = globalAlias, search = search)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetBucketInfoResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v2/GetBucketInfo
     * 
     *  Given a bucket identifier (&#x60;id&#x60;) or a global alias (&#x60;alias&#x60;), get its information. It includes its aliases, its web configuration, keys that have some permissions on it, some statistics (number of objects, size), number of dangling multipart uploads, and its quotas (if any).     
     * @param id Exact bucket ID to look up (optional)
     * @param globalAlias Global alias of bucket to look up (optional)
     * @param search Partial ID or alias to search for (optional)
     * @return ApiResponse<GetBucketInfoResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun getBucketInfoWithHttpInfo(id: kotlin.String?, globalAlias: kotlin.String?, search: kotlin.String?) : ApiResponse<GetBucketInfoResponse?> = withContext(Dispatchers.IO) {
        val localVariableConfig = getBucketInfoRequestConfig(id = id, globalAlias = globalAlias, search = search)

        return@withContext request<Unit, GetBucketInfoResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getBucketInfo
     *
     * @param id Exact bucket ID to look up (optional)
     * @param globalAlias Global alias of bucket to look up (optional)
     * @param search Partial ID or alias to search for (optional)
     * @return RequestConfig
     */
    fun getBucketInfoRequestConfig(id: kotlin.String?, globalAlias: kotlin.String?, search: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (id != null) {
                    put("id", listOf(id.toString()))
                }
                if (globalAlias != null) {
                    put("globalAlias", listOf(globalAlias.toString()))
                }
                if (search != null) {
                    put("search", listOf(search.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/GetBucketInfo",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /v2/InspectObject
     * 
     *  Returns detailed information about an object in a bucket, including its internal state in Garage.  This API call can be used to list the data blocks referenced by an object, as well as to view metadata associated to the object.  This call may return a list of more than one version for the object, for instance in the case where there is a currently stored version of the object, and a newer version whose upload is in progress and not yet finished.     
     * @param bucketId 
     * @param key 
     * @return InspectObjectResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun inspectObject(bucketId: kotlin.String, key: kotlin.String) : InspectObjectResponse = withContext(Dispatchers.IO) {
        val localVarResponse = inspectObjectWithHttpInfo(bucketId = bucketId, key = key)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as InspectObjectResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v2/InspectObject
     * 
     *  Returns detailed information about an object in a bucket, including its internal state in Garage.  This API call can be used to list the data blocks referenced by an object, as well as to view metadata associated to the object.  This call may return a list of more than one version for the object, for instance in the case where there is a currently stored version of the object, and a newer version whose upload is in progress and not yet finished.     
     * @param bucketId 
     * @param key 
     * @return ApiResponse<InspectObjectResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun inspectObjectWithHttpInfo(bucketId: kotlin.String, key: kotlin.String) : ApiResponse<InspectObjectResponse?> = withContext(Dispatchers.IO) {
        val localVariableConfig = inspectObjectRequestConfig(bucketId = bucketId, key = key)

        return@withContext request<Unit, InspectObjectResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation inspectObject
     *
     * @param bucketId 
     * @param key 
     * @return RequestConfig
     */
    fun inspectObjectRequestConfig(bucketId: kotlin.String, key: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("bucketId", listOf(bucketId.toString()))
                put("key", listOf(key.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/InspectObject",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /v2/ListBuckets
     * 
     * List all the buckets on the cluster with their UUID and their global and local aliases.
     * @return kotlin.collections.List<ListBucketsResponseItem>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun listBuckets() : kotlin.collections.List<ListBucketsResponseItem> = withContext(Dispatchers.IO) {
        val localVarResponse = listBucketsWithHttpInfo()

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<ListBucketsResponseItem>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v2/ListBuckets
     * 
     * List all the buckets on the cluster with their UUID and their global and local aliases.
     * @return ApiResponse<kotlin.collections.List<ListBucketsResponseItem>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun listBucketsWithHttpInfo() : ApiResponse<kotlin.collections.List<ListBucketsResponseItem>?> = withContext(Dispatchers.IO) {
        val localVariableConfig = listBucketsRequestConfig()

        return@withContext request<Unit, kotlin.collections.List<ListBucketsResponseItem>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation listBuckets
     *
     * @return RequestConfig
     */
    fun listBucketsRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/ListBuckets",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /v2/UpdateBucket
     * 
     *  All fields (&#x60;websiteAccess&#x60; and &#x60;quotas&#x60;) are optional. If they are present, the corresponding modifications are applied to the bucket, otherwise nothing is changed.  In &#x60;websiteAccess&#x60;: if &#x60;enabled&#x60; is &#x60;true&#x60;, &#x60;indexDocument&#x60; must be specified. The field &#x60;errorDocument&#x60; is optional, if no error document is set a generic error message is displayed when errors happen. Conversely, if &#x60;enabled&#x60; is &#x60;false&#x60;, neither &#x60;indexDocument&#x60; nor &#x60;errorDocument&#x60; must be specified.  In &#x60;quotas&#x60;: new values of &#x60;maxSize&#x60; and &#x60;maxObjects&#x60; must both be specified, or set to &#x60;null&#x60; to remove the quotas. An absent value will be considered the same as a &#x60;null&#x60;. It is not possible to change only one of the two quotas.     
     * @param id ID of the bucket to update
     * @param updateBucketRequestBody 
     * @return GetBucketInfoResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun updateBucket(id: kotlin.String, updateBucketRequestBody: UpdateBucketRequestBody) : GetBucketInfoResponse = withContext(Dispatchers.IO) {
        val localVarResponse = updateBucketWithHttpInfo(id = id, updateBucketRequestBody = updateBucketRequestBody)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetBucketInfoResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /v2/UpdateBucket
     * 
     *  All fields (&#x60;websiteAccess&#x60; and &#x60;quotas&#x60;) are optional. If they are present, the corresponding modifications are applied to the bucket, otherwise nothing is changed.  In &#x60;websiteAccess&#x60;: if &#x60;enabled&#x60; is &#x60;true&#x60;, &#x60;indexDocument&#x60; must be specified. The field &#x60;errorDocument&#x60; is optional, if no error document is set a generic error message is displayed when errors happen. Conversely, if &#x60;enabled&#x60; is &#x60;false&#x60;, neither &#x60;indexDocument&#x60; nor &#x60;errorDocument&#x60; must be specified.  In &#x60;quotas&#x60;: new values of &#x60;maxSize&#x60; and &#x60;maxObjects&#x60; must both be specified, or set to &#x60;null&#x60; to remove the quotas. An absent value will be considered the same as a &#x60;null&#x60;. It is not possible to change only one of the two quotas.     
     * @param id ID of the bucket to update
     * @param updateBucketRequestBody 
     * @return ApiResponse<GetBucketInfoResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun updateBucketWithHttpInfo(id: kotlin.String, updateBucketRequestBody: UpdateBucketRequestBody) : ApiResponse<GetBucketInfoResponse?> = withContext(Dispatchers.IO) {
        val localVariableConfig = updateBucketRequestConfig(id = id, updateBucketRequestBody = updateBucketRequestBody)

        return@withContext request<UpdateBucketRequestBody, GetBucketInfoResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation updateBucket
     *
     * @param id ID of the bucket to update
     * @param updateBucketRequestBody 
     * @return RequestConfig
     */
    fun updateBucketRequestConfig(id: kotlin.String, updateBucketRequestBody: UpdateBucketRequestBody) : RequestConfig<UpdateBucketRequestBody> {
        val localVariableBody = updateBucketRequestBody
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("id", listOf(id.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/v2/UpdateBucket",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
